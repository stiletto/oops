<body>
<ul>
<li><b>nameserver</b><br>
   Для трансляции имен в адреса обычно используют функции семейства
gethostbyname (сразу замечу что OOPS их старается не использовать, дальше
станет ясно почему). Использование этих вызовов удобно по нескольким
причинам: во-первых, это просто, во-вторых - gethostbyname позволяет
использовать не только DNS в качестве источника информации об IP-адресах, но
и nis, файлы hosts и т.д. К сожалению, при определенных условиях
gethostbyname (и thread-safe вариант gethostbyname_r) представляют собой
существенный "тормоз" при попытке параллельного резолвинга нескольких имен,
а именно: имена будут резолвиться по-очереди. Поэтому OOPS использует свой
внутренний простенький резолвер, лишенный этого недостатка (зато имеющий
другие...). На сегодняшний день он осуществляет только трансляцию имен в
адреса и для этого ему нужен nameserver, которому OOPS посылает запросы.<br>

   В конфиге может быть несколько строк <b>nameserver</b>. Запросы к ним
посылаются по очереди, начиная с первого. После отправки первого запроса
к первому серверу выдерживается небольшая пауза (в надежде что он ответит
и последующие запросы не понадобятся). Если ответа нет, мы с увеличивающимся
интервалом начинаем периодически рассылать запросы всем серверам. Успешные
ответы кэшируются и хранятся в течение получаса для того, чтобы не 
накладывать большую нагузку на nameserver. <br>

   Строки <b>nameserver</b> могут вовсе отсутствовать в конфиге, в этом
случае OOPS будет работать через gethostbyname, со всеми вытекающими
последствиями.

<li><b>bind</b><br>
   ip-адрес, на котором будут приниматься запросы. Если машина, на которой
работает OOPS, имеет имеет несколько интерфейсов (или алиасов), то по умолчанию
будут приниматься соединения, приходящие на любой из этих адресов. Иногда
это неудобно. Например, Вы хотите, что-бы OOPS принимал соединения, приходящие
только на интерфейсе, обращенном в сторону Вашей локальной сети. В этом
случае в опции <b>bind</b> укажите имя хоста (или ip-адрес) на котором
OOPS должен слушать. Учтите, если интерфейса с указанным адресом на машине
нет, то эта опция не сработает, OOPS будет слушать на всех адресах.

<li><b>http_port</b><br>
   Это номер порта, на котором http-прокси будет принимать запросы. Эта
стока может отсутствовать, тогда будет использоваться умолчание: 3128.
Для того, что-бы отключть http-прокси можно использовать номер порта 0.
К этой опции так-же имеет отношение опция <b>bind</b> она указывает на
каком именно ip-адресе OOPS будет слушать (по умолчанию - на всех).

<li><b>icp_port</b><br>
   Номер порта, на котором принимаются ICP-запросы.

<li><b>connect-from</b><br>
   Если эта опция отсутствует, то OOPS при установлении соединения c
http-сервером OOPS не будет пытаться установить какого-либо адреса для
своего конца соединения. Это может быть неудобно: например, Ваша машина
имеет на эзернете два адреса, причем первым установлен адрес, который
резолвится <b>не</b> в имя proxy.yourdomain.tld. В этом случае исходящие
соединения, скорее всего, будут устанавливаться от неподходящего имени.
Для исправления этой ситуации служит connect-from - эта опция "фиксирует"
адрес, с которого устанавливаются соединения.

<li><b>bind_acl</b><br>
   Это более гибкий вариант предыдущей директивы (за гибкость нужно платить
использование этой директивы увеличивает накладные расходы на обработку
каждого запроса). Эта директива работает следующим образом: если запрос
удовлетворяет указанноми ACL, то при соединении с http-сервером нашему
концу соединения будет присвоен соответствующий ip-адрес.<br>

   Таких директив может быть несколько, каждый запрос проходит через
все перечисленные ACL в порядке появления в конфиге, до первого совпадения.
Если ни одна строка не сработала, используется директива connect-from, а
если ее нет, то никакой привязки не производится.

<li><b>lo_mark</b><br>
   OOPS имеет двухуровневый кэш: кэш в памяти и кэш на диске. Во время
обслуживания запроса пользователя документ сначала ищется в памяти, затем,
в случае неудачи, на диске. Любой вновь принимаемый документ сначала
помещается в in-memory кэш, откуда он рано или поздно может попасть на диск.
После старта программы обьем закэшированных в памяти документов начинает
расти. lo_mark устанавливает предел, до которого этот объем модет дойти.
Как только этот предел достигнут, документы начинают сбрасываться на диск,
и этот процесс продолжается до тех пор, пока объем документов в памяти
не вернется в нужные рамки. Кстати, именно поэтому, если Вы запустили OOPS
на 10 минут и приняли через него 10 документов, скорее всего на диске
никаких следов этих документов не обнаружится. Учтите также, что
максимальный суммарный размер документов не означает "допустимый размер
программы в памяти". Размер пограммы в памяти всегда больше чем lo_mark
и, как правило, раза в три превышает lo_mark. На размер программы в памяти
влияют такие параметры, как maxresident, размер внутреннего кэша BerkeleyDB
и то, какую стратегию захвата/освобождения памяти используют функции
malloc/free.<br>

   Процесс подсчета суммарного обьема документов и сравнения с lo_mark
происходит раз в 10 секунд.<br>

   Т.о., рассматривайте lo_mark как как "хинт", указание на то, до каких
пределов программа может расти в памяти. Реальный размер будет в среднем
раза в три больше чем lo_mark.

<li><b>mem_max</b><br>
   Тоже предел на размер памяти. При сильной загрузке скорость поступления
кэшируемых документов может превысить скорость, с которой OOPS может
сбрасывать их на диск. При этом окажется, что OOPS будет безгранично
расти в памяти. mem_max предотвращает такую неприятность: если суммарный обьем
документов в памяти превысит mem_max, документы просто уничтожаются
в памяти, не попадая на диск (естественно до тех пор, пока обьем не
опустится до mem_max). При небольшой (и даже при средней) нагрузке
такого не происходит, поэтому не следует устанавливать mem_max слишком
близко к lo_mark. Соотношение mem_max = 2*lo_mark является вполне приемлемым.

<li><b>userid</b><br>
   хотя были приложены все усилия для того, чтобы программу нельзя было
использовать для взлома системы, Вы не обязаны верить в то, что эти усилия
увенчались успехом. Поэтому сразу после старта программа может сменить
текущий uid на uid непривилегированного пользователя для того, чтобы
последствия такого взлома были минимальными. Вы можете не использовать
эту опцию, тогда OOPS будет работать от имени того пользователя, от имени 
которго он был запущен.<br>

   При использовании <b>userid</b> возникают некоторые ограничения на
процедуру реконфигурации. В частности, Вы не сможете создать новый порт
для приема соединений с номером порта ниже 1024.<br>

   Если Вы используете эту опцию - <b>очень важно</b> чтобы все файлы,
к которым OOPS должен иметь доступ, имели соответствующие права доступа для
выбранного пользователя.<br>

   Также важно, чтобы OOPS запускался от рута - это позволяет ему снять
ограничения, накладываемые системой на использование ресурсов: числа
открытых файлов, обьем используемой памяти и т.д. Если OOPS запускается
не от рута, то OOPS не сможет снять этих ограничений, что может быстро
привести к проблемам.

<li><b>stop_cache</b><br>
   Простейший (и самый быстрый) способ управления кэшируемостью документов.
Если эта инструкция есть в конфиге, то для любого запроса выполняется
следующая проверка: входит ли строка, фигурирующая в опции как подстрока в
пути, фигурирующем в запросе. Например, директива 'stop_cache ?' предотвращает
кэширование любого URL вида http://hostname/path?request. <b>Внимание!</b>
сравнению подвергается только путь!

<li><b>stop_cache_acl</b><br>
    Более гибкий вариант предыдущей инструкции. Документы, полученные в
результате обслуживания запросов, подпадающих под данные ACL, не будут
закэшированы.

<li><b>local_domain</b><br>
   В случае, если используется какя-либо иерархия кэшей (icp или parent)
local_domain указывает, какие домены являются для Вас локальными и
удовлетворение запросов к этим доменам не требует взаимодействия с другими
кэшами.

<li><b>local_networks</b><br>
    Аналогично <b>local_domain</b>, но перечисляются сети, а не домены.
Использование local_networks с необходимостью приводит к тому, что во время
обработки каждого запроса приходится резолвить хостовую часть URL (даже
если после этого окажется, что запрос уйдет к перенту), что может привести к
замедлению работы. Так что, если возможно - избегайте этой опции.

<li><b>default_expire_value</b><br>
    В случае, если в документе полученном от сервера отсутствует заголовок
"Expire:" и отсутствуют любые другие источники информации о времени, когда
документ может считаться устаревшим, oops использует значение из опции
default_expire_value. На решение о дате устаревания документа влияют следующие
опции: default_expire_value, refresh_pattern, max-expire-value,
last-modified-factor.

<li><b>refresh_pattern</b><br>
    Эта опция применяется в случае, если нужно "насильно" устанавливать
некоторое значение Expire для некоторых документов. Опция имеет четыре
аргумента: ACLNAME, min, percent, max. ACLNAME - имя acl, используемое для
отделения интересуемых документов. min и max - соответственно, минимальное и
максимальное время Expire для документа (указывается в секундах). percent -
процент, в котором учитывается время последней модификации (имеется ввиду,
что если документ изменялся недавно, то можно предполагать как скоро он
изменится снова). percent учитывается только в том случае, если документ не
содержит заголовка "Expire:", и работает следующем образом: вычисляется время,
прошедшее с момента модификации документа, от него берется указанный процент
и считается, что момент устаревания наступит через полученное число секунд в
будущем.

<li><b>disk_low_free, disk_ok_free</b><br>
    Эти параметры управляют процессом "чистки" дисковых хранилищ. Раз в 10
секунд происходит определение суммарного свободного места во всех
хранилищах. Если этот объем становится меньше, чем disk_low_free процентов,
начинается процесс чистки. Этот процесс продолжается до тех пор, пока обьем
свободного пространства не увеличится до disk_ok_free, либо не наступит
событие, прерывающее всякую работу с дисками (reconfigure или shutdown).

<li><b>force_http11</b><br>
    Включает преобразование HTTP-версии запроса от пользователя в HTTP/1.1
во время отправления запроса к серверу.

<li><b>always_check_freshness  и always_check_freshness_acl</b><br>
    Заставляет oops проверять свежесть закэшированного документа на сервере
при обращении ползователя за этим документом. Отличие между первой и второй
формой инструкции в том, что always_check_freshness включает безусловную
проверку для всех кэшированных документов. always_check_freshness_acl -
только для тех документов/запросов, которые подпадают под указанные acl.
Если ни одна из этих опций не указана, oops будет проверять свежесть
закэшированного документа только в том случае, если пользователь это явно
запросил либо срок свежести документа истек.

<li><b>force_completion</b><br>
    Если пользователь запросивший какой-либо документ решил прервать прием
документа и больше никто этот документ в этот-же момент времени не получает,
то OOPS может оборвать прием документа (передача автоматически обрывается
как только пользователь отказался от приема). Это сохраняет входной канал
потому что OOPS не будет принимать документ, который наверное сейчас никому
не нужен. С другой стороны этот документ может быть полезен позже, кроме
того, какя-то часть канальных мощностей уже затрачена на прием части
документа. В этом случае Вы можете решить что лучше всё-таки документ
докачать. force_completion определяет, какая часть документа (в %%) должна
быть принята для того, чтобы OOPS дотягивал его в любом случае.

<li><b>insert_x_forwarded_for, insert_via</b><br>
    Значения yes или no заставляют вставлять или не вставлять соответственно
заголовки X-Forwarded-For: и Via: в запросы к серверу.

<li><b>acl</b><br>
    Определяет поименованный ACL. Описания в большинстве случаев интуитивно
ясны. Смотри oops.cfg для примеров.

<li><b>acl_deny</b><br>
    Запрещает обслуживание запросов подпадающих под перечисленные acl-и.
    
<li><b>parent</b><br>
    Использование этой инструкции приводит к тому что НИ ОДИН запрос (за
исключением случаев описанных ниже) не будет обслуживаться напрямую, а
только через указанного парента. По-прежнему напрямую обслуживаются запросы,
подпадающие под определения local_domain и local_networks. Вы можете
использовать эту инструкцию если Вы имеете один канал наружу и
надежно работающий кэш верхнего уровня. Другие варианты взваимодействия с
кэшами смотри в разделе <b>peer</b>.

<li><b>parent_auth</b><br>
    Если parent, описанный в предыдущем пункте, требует авторизации - её
можно включить этой опцией.

<li><b>peer</b><br>
    Эта секция описывает ваших прямых соседей в кэш-иерархии. OOPS может
взаимодействовать с peer-ами используя и не используя протокол ICP.
Параметрами инструкции peer являются HTTP-порт соседа, ICP-порт соседа, за
ними следует перчисление параметров и свойств соседа. HTTP-порт - это порт,
на котором сосед принимает HTTP запросы. ICP-порт - порт на котором сосед
принимает ICP запросы. ICP-порт может быть нулевым. Это означает, что сосед
не работает по протоколу ICP. Это приводит к некоторому изменению в
алгоритме работы с этим соседом (см.ниже).

    <ul>
    <li>sibling|parent<br>
	Эта опция определяет, кем для вас является сосед. Parent позволяет
        вам запрашивать у него документы, даже если их нет в его кэше. Т.е.,
        он их будет тянуть для Вас из сети. Sibling не позволит Вам этого
        сделать - он будет отдавать только то, что есть в его кэше. Так
        что правильное значение этого поля - вопрос административный. 
        Скорее всего, нужно спросить у администратора соседа, кем он для
		вас является.

    <li>my_auth<br>
	Эта опция нужна, если ваш сосед требует от вашего прокси авторизации.

    <li>allow|deny<br>
	Эти опции можно использовать, если Вы не хотите, чтобы какие-то
	запросы обслуживались через этого соседа. Здесь могут быть
	перечислены домены. Более гибкое управление можно осуществлять с
	использованием опции peer_access.

    <li>peer_access<br>
	Эту опцию можно использовать для "тонкой" настройки того, какие
	запросы обслуживать через данного соседа. Этих опций может быть
	несколько, можно использовать любые ACL (с и без знака "!").

    <li>down_timeout<br>

	Эта опция вступает в силу только в том случае, если сосед
	не-ICP-capable (ICP-порт равен 0). В этом случае взаимодействие с
	соседом происходит следующим образом: ICP запросы соседу не
	посылаются.  Вместо этого считается что сосед всегда отвечает MISS. 
	Это значит, что если како-либо сосед из тех, кому запросы были
	посланы (если таковые соседи есть) ответит HIT, то за документом
	OOPS пойдет к нему(ответившему HIT). Поскольку выяснить доступность
	и работоспособность соседа представляется возможным только путем
	посылки ему HTTP-запроса, то алгоритм перехода соседа в состояния
	UP/DOWN таков: если какое-либо соединение на HTTP-порт не
	завершилось успешно, сосед переводится в состояние DOWN и он
	исключается из рассмотрения на down_timeout секунд. По истечение
	этого периода он переводится в состояние UP.

    </ul>

<li><b>group</b><br>
    Все пользователи или их запросы попадают в ту или иную группу. Параметры
    обслуживания запросов описываются применительно к группе. Вопрос о том,
    в какую группу попадает данный запрос решается следующим образом:<br>

	Если в описаниях групп присутствуют опции networks_acl, тогда
	сначала делается попытка определить принадлежность запроса через
	действие ACL: все networks_acl просматриваются в порядке их
	появления в конфиге. При первом совпадении просмотр завершается. 
	<br> Если в конфиге небыло опций networks_acl или их просмотр
	закончился неудачно, пытаемся определить принадлежность, используя
	директивы networks. Все сети, входящие в директивы networks,
	отсортированы так, что наиболее специфичные сети (наиболее длинные
	сетевые маски) при поиске просматриваются первыми. Если адрес, с
	которого пришел запрос, попадает в какую-либо сеть, то запрос
	попадает в ту группу, где описана данная сеть.

    <ul>
	<li>networks<br> Перечень сетей и хостов, запросы с которых
	    попадают в данную группу. Сети записываются в формате
	    aaa.bbb.ccc/length. Для хостов длина маски равна 32.
	    
	<li>networks_acl</br> ACL, применяемый к запросу для определения
	    группы, в которую попадет запрос.

	<li>badports<br>
	    Список портов, соединение на которые запрещено. Используйте те,
	    что идут в примере, и расширяйте этот список по желанию.

	<li>miss allow|deny<BR>
		Эта опция управляет доступом к вашему кэшу со стороны кэшей-соседей.
		Если Вы выберите значение deny, то клиент, запросивший документ,
		отсутствующий в кэше получит отказ. Вы можете завести для
		кэшей-соседей группы, в которых сможете гибко управлять
		параметрами обслуживания.

	<li>denytime<br>
	    Перечислены интервалы времени, в которые пользователям этой
	    группы доступ будет закрыт. параметр имеет форму:
	       список-дней время-с:время-до

	    список-дней - перечисленные через запятую отдельные дни или
	    интервалы дней (например Thu:Fri). Обратите внимание: интервал
	    должен быть неубывающим (т.е. первый день в интервале должен
	    быть "меньше" второго дня, порядок дней Sun,Mon,Tue,Wed,Thu,Fri,Sat).

	<li>auth_mods<br>
	    Модуль, занимающийся авторизацией пользователей в этой группе
	    (если необходима авторизация).

	<li>redir_mods<br>
	    Модули-редиректоры, которые будут применены к запросам из этой
	    группы. Если перечислено несколько, то они будут вызываться в
	    указанном порядке.

	<li>bandwidth<br>
		Полоса пропускания в байт/секунду для этой группы. 
	    Эта величина ограничивает обьем данных передаваемых в секунду
	    для всех запросов, попадающих в эту группу. Пересчет траффика
	    ппроизводится раз в секунду, что может приводить к не очень
	    точному соблюдению лимита. Более высокое качество может быть
	    получено при более частом пересчете, но это будет приводить к
	    росту накладных расходов.

	<li>per_ip_bw<br>
		Аналогично предыдущему пункту, но ограничения накладываются
		на поток к каждому хосту в группе. На группу могут быть наложены
		оба ограничения.

	<li>per_ip_conn<br>
		Максимальное количество соединений с одного хоста,
		которое может быть открыто одновременно.

	<li>maxreqrate<br>
		Максимальный темп запросов (количество запросов в секунду),
		допустимый для этой группы.

	<li>http<br>
	Исторически самая первая форма ограничения доступа группы к
	определенным доменам. В разделе allow перечисляйте домены, к которым
	доступ разрешен (допустимо использование *); в разделе deny
	перечисляйте домены, к которым доступ запрещен.

	<li>icp<br>
	не делает ничего.

	<li>storage<br> Эта секция описывает хранилища. Хранилище
	представляет собой цельный файл, в котором хранятся документы. Файл
	может быть либо "обычным" файлом, либо разделом на диске. Перед
	использованием хранилища должны быть отформатированы (командой oops
	-z). oops может работать и без хранилищ.

	Параметрами хранилища являются:
	<ul>
	<li>path<br> - путь к файлу.

	<li>size<br> - размер хранилища. Используется только во время
	форматирования. Может принимать любые значения (не меньше нескольких
	килобайт). Использование больших хранилищ (размером более 2G)
	требует использования опции --enable-large-files в процессе
	конфигурирования. Если файл является разделом или уже заранее создан
	вами, то на этапе форматирования в качестве размера может быть
	указано слово 'auto'. В этом случае oops сам определит размер файла
	и отформатирует его в полном обьеме.

	<li>offset<br> указывает смещение в байтах для всех хранимых в
	storage структур. Эта опция нужна в случае использования в качестве
	хранилищ слайсов под Solaris/sparc или AIX. В этих системах в первых
	секторах слайсов располагаются метки тома, котроые не должны быть
	затерты.

